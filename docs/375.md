# Page 350-375

## Exception handling

At  the  point  where  an  exception  isthrown,  all  memory  allocated  must  be  either  deallocated  or  owned  by  some  object,  which  in  turn must ensure that the memory is properly deallocated. For example:

    void f(int i)
    {
        int∗ p = new int[10];
        // ...
        if (i<0) {
            delete[] p;     // delete before the throw or leak
            throw Bad();
    }
    // ...
    }

## Example (not a good one, but whatever)

int main()
{
    int n;
    cin >>n;
    if (n<0)
        throw range_error("Bad range");
}

## Resource management

A first attempt to make `use_file()` fault-tolerant looks like this:

    void use_file(const char∗ fn) // clumsy code
    {
        FILE∗ f = fopen(fn,"r");
        try {
            // ... use f ...
        }
        catch (...) { // catch every possible exception
            fclose(f);
            throw;
        }
        fclose(f);
    }

The general form of the problem looks like this:

    void acquire()
    {
        // acquire resource 1
        // ...
        // acquire resource n

        // ... use resources ...
        
        // release resource n
        // ...
        // release resource 1
    }

It  is  typically  important  that  resources  are  released  in  the  reverse  order  of  their  acquisition.

For example, we can define a class File_ptr that acts like a FILE∗:

    class File_ptr {
        FILE∗ p;
    public:
        File_ptr(const char∗ n, const char∗ a)      // open file n
            :p{fopen(n,a)}
        {
            if (p==nullptr) throw runtime_error{"File_ptr: Can't open file"};
        }
        File_ptr(const string& n, const char∗ a)    // open file n
            :File_ptr{n.c_str(),a}
        { } 
        explicit File_ptr(FILE∗ pp)                 // assume ownership of pp
            :p{pp}
        {
            if (p==nullptr) throw runtime_error("File_ptr: nullptr"};
        }

        // ... suitable move and copy operations ...

        ̃File_ptr() { fclose(p); }

        operator FILE∗() { return p; }
    };

Our function now shrinks to this minimum:

    void use_file(const char∗ fn)
    {
        File_ptr f(fn,"r");
        // ... use f ...
    }

## Throwing Exceptions

We  can throw an exception of any type that can be copied or moved.  For example:

    class No_copy {
        No_copy(const No_copy&) = delete; // prohibit copying (§17.6.4)
    };

    class My_error {
        // ...
    };

    void f(int n)
    {
        switch (n) {
            case 0: throw My_error{};   // OK
            case 1: throw No_copy{};    // error : can’t copy a No_copy
            case 2: throw My_error;     // error : My_error is a type, rather than an object
        }
    }

## `noexcept` Functions
Some functions don’t throw exceptions and some really shouldn’t.  To indicate that, we can declare such a function `noexcept`. For example:

double compute(double) noexcept;    // may not throw an exception

Now no exception will come out of `compute()`.

## The noexcept Operator

It is possible to declare a function to be conditionally `noexcept`. For example:

template<typename T>
void my_fct(T& x) noexcept(Is_pod<T>());

The `noexcept(Is_pod<T>())` means that `My_fct` may not throw if the predicate `Is_pod<T>()` is `true` but may throw if it is `false`.

## Catch Every Exception

In <stdexcept>, the standard library provides a small hierarchy of exception classes with a common base exception.  For example:

    void m()
    {
        try {
            // ... do something ...
        }
        catch (std::exception& err) { // handle every standard-librar y exception
            // ... cleanup ...
            throw;
        }
    }

This  catches  every  standard-library  exception. However,  the  standard-library  exceptions  are  justone set of exception types. Consequently, you cannot catch every exception by catching `std::excepion`. If someone (unwisely) threw an `int` or an exception from some application-specific hierarchy, it would not be caught by the handler for `std::exception&`.

As for functions, the ellipsis, ..., indicates ‘‘any argument’’, so `catch(...)` means ‘‘catch any exception.’’  For example:

    void m()
        {
        try {
            // ... something ...
        }
        catch (...) { // handle every exception
            // ... cleanup ...
        throw;
        }
    }

## Multiple Handlers

    void f()
    {
        try {
            // ...
        }
        catch (std::ios_base::failure) {
            // ... handle any iostream error (§30.4.1.1) ...
        }
        catch (std::exception& e) {
            // ... handle any standard-librar y exception (§30.4.1.1) ...
        }
        catch (...) {
            // ... handle any other exception (§13.5.2.2) ...
        }
    }

## Function try-Blocks

The body of a function can be a try-block.  For example:

    int main()
    try
    {
        // ... do something ...
    }
    catch (...} {
        // ... handle exception ...
    }

For most functions, all we gain from using a function try-block is a bit of notational convenience. However,  a try-block  allows  us  to  deal  with  exceptions  thrown  by  base-or-member  initializers  in constructors

