# Page 75-100

## Templates

    template<typename T>
    class Vector {
    private:
        T∗ elem;                        // elem points to an array of sz elements of type T
        int sz;
    public:
        Vector(int s);                  // constructor: establish invariant, acquire resources
        ~Vector() { delete[] elem; }    // destructor: release resources

        // ... copy and move operations ...

        T& operator[](int i);
        const T& operator[](int i) const;
        int size() const { return sz; }
    };

The `template<typename T>` prefix makes T a parameter of the declaration it prefixes.  It is C++’s ver-
sion of the mathematical ‘‘for all T’’ or more precisely ‘‘for all types T.’’

The member functions might be defined similarly:

    template<typename T>
    Vector<T>::Vector(int s)
    {
        if (s<0) throw Negative_siz e{};
        elem = new T[s];
        sz = s;
    }

    template<typename T>
    const T& Vector<T>::operator[](int i) const
    {
        if (i<0 || size()<=i)
            throw out_of_rang e{"Vector::operator[]"};
        return elem[i];
    }

Given these definitions, we can define Vectors like this:

    Vector<char> vc(200);           // vector of 200 characters
    Vector<string> vs(17);          // vector of 17 strings
    Vector<list<int>> vli(45);      // vector of 45 lists of integers

We can use `Vectors` like this:

    void write(const Vector<string>& vs)    // Vector of some strings
    {
        for (int i = 0; i!=vs.size(); ++i)
            cout << vs[i] << '\n';
    }

To support the range-for loop for our `Vector`, we must define suitable begin() and end() functions:

    template<typename T>
    T∗ begin(Vector<T>& x)
    {
        return &x[0]; // pointer to first element
    }

    template<typename T>
    T∗ end(Vector<T>& x)
    {
        return x.begin()+x.size();          // pointer to one-past-last element
    }

Given those, we can write:

    void f2(const Vector<string>& vs)       // Vector of some strings
    {
        for (auto& s : vs)
            cout << s << '\n';
    }

## Template functions

We  can  write  a  function  that  calculates  the  `sum`  of  the element values of any `container` like this:

    template<typename Container, typename Value>
    Value sum(const Container& c, Value v)
    {
        for (auto x : c)
            v+=x;
        return v;
    }

## Lambda

    void f(const Vector<int>& vec, const list<string>& lst, int x, const string& s)
    {
        cout << "number of values less than " << x
            << ": " << count(vec,[&](int a){ return a<x; })
            << '\n';
        cout << "number of values less than " << s
            << ": " << count(lst,[&](const string& a){ return a<s; })
            << '\n';
    }

The  notation `[&](int  a){  return  a<x;  }` is  called  a lambda  expression. It generates  a  function object  exactly  like `Less_than<int>{x}`. The `[&]` is  a capture list specifying  that  local  names  used (such  as `x`) will  be  passed  by  reference. Had  we  wanted  to  ‘‘capture’’ only `x`, we could  have  said so: `[&x]`. Had we wanted to give the generated object a copy of `x`, we could have said so: `[=x]`. Capture nothing is `[]`, capture all local names used by reference is `[&]`, and capture all local names used by value is `[=]`.

## String

    string name = "Niels Stroustrup";

    void m3()
    {
        string s = name.substr(6,10);       // s = "Stroustr up"
        name.replace(0,5,"nicholas");       // name becomes "nicholas Stroustrup"
        name[0] = toupper(name[0]);         // name becomes "Nicholas Stroustrup"
    }

`substr(begin, len)`
`.replace(begin, len, str)`

## List

    list<T> phone_book

    int get_number(const string& s)
    {
        for (const auto& x : phone_book)
            if (x.name==s)
                return x.number;
        return 0; // use 0 to represent "number not found"
    }

The  search  for `s` starts  at  the  beginning  of  the  `list`  and  proceeds  until `s` is  found  or  the  end  of `phone_book` is reached.

or:

    int get_number(const string& s)
    {
        for (auto p = phone_book.begin(); p!=phone_book.end(); ++p)
            if (p−>name==s)
                return p−>number;
        return 0; // use 0 to represent "number not found"
    }

Adding elements to a list and removing elements from a list is easy:

    void f(const Entry& ee, list<Entr y>::iterator p, list<Entry>::iterator q)
    {
        phone_book.insert(p,ee);        // add ee before the element referred to by p
        phone_book.erase(q);            // remove the element referred to by q
    }