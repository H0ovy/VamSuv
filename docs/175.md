# Page 150-175

    int x, y;       // int x; int y;
    int∗ p, y;      // int* p; int y; NOT int* y;
    int x, ∗q;      // int x; int* q;
    int v[10], ∗pv; // int v[10]; int* pv;

## Scope

    nt x; // global x
    void f()
    {
        int x;      // local x hides global x
        x = 1;      // assign to local x
        {
            int x;  // hides first local x
            x = 2;  // assign to second local x
        }
        x = 3;      // assign to first local x
    }
    int∗ p = &x;    // take address of global x

reference to a hidden global name:

    nt x;
    void f2()
    {
        int x = 1;  // hide global x
        ::x = 2;    // assign to global x
        x = 2;      // assign to local x
        // ...
    }

or:

    int x = 11;
    void f4()       // per verse: use of two different objects both called x in a single scope
    {
        int y = x;  // use global x: y = 11
        int x = 22;
        y = x;      // use local x: y = 22
    }

## Initialization

    X a1 {v};
    X a2 = {v};
    X a3 = v; 
    X a4(v);

However, anything more complicated is better done using `{}`. Initialization using `{}`, list initialization, does not allow narrowing. That is:
- An integer cannot be converted to another integer that cannot hold its value.  For example, `char` to `int` is allowed, but not `int` to `char`.
- A floating-point value cannot be converted to another floating-point type that cannot hold its value.  For example, `float` to `double` is allowed, but not `double` to `float`.
- A `floating-point` value cannot be converted to an i`nteger` type.
- An `integer` value cannot be converted to a `floating-point` type.

There  is  no  advantage  to  using `{}` initialization,  and  one  trap,  when  using auto to  get  the  type determined by the initializer. The trap is that if the initializer is a `{}-list`, we may not want its type deduced. For example:

    auto z1 {99}; // z1 is an initializer_list<int>
    auto z2 = 99; // z2 is an int

So prefer `=` when using `auto`.

    vector<int> v1 {99}; // v1 is a vector of 1 element with the value 99
    vector<int> v2(99); // v2 is a vector of 99 elements each with the default value 0

## Pointers (f them)

    char c = 'a';
    char∗ p = &c; // p holds the address of c; & is the address-of operator
    char c2 = ∗p; // c2 == ’a’; * is the dereference operator

    int∗ pi; // pointer to int
    char∗∗ ppc; // pointer to pointer to char
    int∗ ap[15]; // array of 15 pointers to ints
    int (∗fp)(char∗); // pointer to function taking a char* argument; returns an int
    int∗ f(char∗); // function taking a char* argument; returns a pointer to int

## `void*`

In  low-level code,  we  occasionally  need  to  store  or  pass  along  an  address  of  a  memory  location without actually knowing what type of object is stored there. A `void∗` is used for that. You can read `void∗` as ‘‘pointer to an object of unknown type.’’

## `nullptr`

The  literal `nullptr` represents  the  null  pointer, that  is,  a  pointer  that  does  not  point  to  an  object. It can be assigned to any pointer type, but not to other built-in types:

    int∗ pi = nullptr;
    double∗ pd = nullptr;
    int i = nullptr;        // error : i is not a pointer

There  is  just  one `nullptr`, which  can  be  used  for  every  pointer  type,  rather  than  a  null  pointer  for each pointer type.

