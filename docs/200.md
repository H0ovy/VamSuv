# Pages 175-200

## String Literals

If we want a string that we are guaranteed to be able to modify, we must place the characters in a non-const array:

    void f()
    {
        char p[] = "Zeno";  // p is an array of 5 char
        p[0] = 'R';         // OK
    }

The escape character, '\a', is the ASCII character BEL (also known as alert), which causes a sound to be emitted.

    cout<<"beep at end of message\a\n";

Long strings can be broken by whitespace to make the program text neater. For example:

    char alpha[] = "abcdefghijklmnopqrstuvwxyz"
                   "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

The compiler will concatenate adjacent strings, so alpha could equivalently have been initialized by
the single string

    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

## Raw Character Strings

To  represent  a  backslash  (\) or a double  quote  (") in a string  literal,  we  have  to precede  it  with  a backslash.

    string s = "\\w\\\\w"; // I hope I got that right

To  prevent the frustration and errors caused by this clash of conventions, C++ provides raw string literals. A raw string  literal  is  a  string  literal  where  a  backslash  is  just  a  backslash  (and  a  double quote is just a double quote) so that our example becomes:

    string s = R"(\w\\w)";  // I’m pretty sure I got that right

    R"("quoted string")"    // the string is "quoted string"

In contrast to nonraw string literals, a raw string literal can contain a newline.
For example:

    string counts {R"(1
    22
    333)"};

is equivalent to

    string x {"1\n22\n333"};

## Pointers into Arrays

    nt v[] = { 1, 2, 3, 4 };
    int∗ p1 = v;        // pointer to initial element (0) (implicit conversion)
    int∗ p2 = &v[0];    // pointer to initial element (0)
    int∗ p3 = v+4;      // pointer to one-beyond-last element (4)

## Navigating The Arrays

    void fi(char v[])
    {
        for (int i = 0; v[i]!=0; ++i)
            use(v[i]);
    }

    void fp(char v[])
    {
        for (char∗ p = v; ∗p!=0; ++p)
            use(∗p);
    }

The prefix ∗ operator dereferences a pointer so that ∗p is the character pointed to by p, and ++ increments the pointer so that it refers to the next element of the array.

## Const and Pointers


C++ offers two related meanings of ‘‘constant’’:
- `constexpr`: Evaluate at compile time.
- `const`: Do not modify in this scope.
Basically, `constexpr`’s  role  is  to  enable  and  ensure  compile-time  evaluation,  whereas `const`’s  primary role is to specify immutability in interfaces.

    char ∗const cp;     // const pointer to char
    char const∗ pc;     // pointer to const char
    const char∗ pc2;    // pointer to const char

Some  people  find  it  helpful  to  read  such  declarations  right-to-left,  for  example,  ‘‘`cp` is  a `const` pointer to a `char`’’ and ‘‘`pc2` is a pointer to a `char const`.’’

## Lvalue References

    void f()
    {
    int var = 1;
        int& r {var};   // r and var now refer to the same int
        int x = r;      // x becomes 1

        r = 2;          // var becomes 2
    }

Initialization  of  a  reference  is  something  quite  different  from  assignment  to  it. Despite  appearances, no operator operates on a reference. For example:

    void g()
    {
        int var = 0;
        int& rr {var};
        ++rr;               // var is incremented to 1
        int∗ pp = &rr;      // pp points to var
    }

Here, `++rr` does not increment the reference `rr`; rather, `++` is applied to the `int` to which `rr` refers, that is,  to `var`.

Consequently, the  value  of  a  reference  cannot  be  changed  after  initialization;  it  always refers to the object it was initialized to denote. To  get a pointer to the object denoted by a reference `rr`, we can write `&rr`. Thus, we cannot have a pointer to a reference. Furthermore, we cannot define an array of references. In that sense, a reference is not an object.

A reference  can  be  used  to  specify  a  function  argument  so  that  the  function  can  change  the value of an object passed to it. For example:

    void increment(int& aa)
    {
        ++aa;
    }

    void f()
    {
        int x = 1;
        increment(x);   // x = 2 
    }

An  rvalue  reference  can  bind  to  an  rvalue,  but  not  to  an  lvalue. In that,  an  rvalue  reference  is exactly opposite to an lvalue reference. For example:

    string var {"Cambridge"};
    string f();

    string& r1 {var};               // lvalue reference, bind r1 to var (an lvalue)
    string& r2 {f()};               // lvalue reference, error : f() is an rvalue
    string& r3 {"Princeton"};       // lvalue reference, error : cannot bind to temporar y
    
    string&& rr1 {f()};             // rvalue reference, fine: bind rr1 to rvalue (a temporar y)
    string&& rr2 {var};             // rvalue reference, error : var is an lvalue
    string&& rr3 {"Oxford"};        // rr3 refers to a temporar y holding "Oxford"

    const string cr1& {"Harvard"};  // OK: make temporar y and bind to cr1

The `&&` declarator operator means ‘‘rvalue reference.’’ 

    template<class T>
    void swap(T& a, T& b)               // "perfect swap" (almost)
    {
        T tmp {static_cast<T&&>(a)};    // the initialization may write to a
        a = static_cast<T&&>(b);        // the assignment may write to b
        b = static_cast<T&&>(tmp);      // the assignment may write to tmp
    }

The  use  of `static_cast` in `swap()` is  a  bit  verbose  and  slightly  prone  to  mistyping,  so  the  standard library  provides  a `move()` function: `move(x)` means `static_cast<X&&>(x)` where X is  the  type  of x. Given that, we can clean up the definition of `swap()` a bit:

    template<class T>
    void swap(T& a, T& b)   // "perfect swap" (almost)
    {
        T tmp {move(a)};    // move from a
        a = move(b);        // move from b
        b = move(tmp);      // move from tmp
    }

`move(x)` does not move `x` (it simply produces an rvalue reference to `x`)

I deemed this swap() ‘‘almost perfect’’ because it will swap only lvalues.  
Consider:

    void f(vector<int>& v)
    {
        swap(v,vector<int>{1,2,3});     // replace v’s elements with 1,2,3
        // ...
    }

It is not uncommon to want to replace the contents of a container with some sort of default value,
but this particular swap() cannot do that. A solution is to augment it by two overloads:

    template<class T> void swap(T&& a, T& b);   // swap rvalue type with lvalue type
    template<class T> void swap(T& a, T&& b);   // swap lvalue type with rvalue type

If  you  take a reference  to  a  reference  to  a  type,  you  get  a  reference  to  that  type,  rather  than  some kind of special reference to reference type. But what kind of reference? Lvalue reference or rvalue reference?  Consider:

    using rr_i = int&&;
    using lr_i = int&;
    using rr_rr_i = rr_i&&;     // ‘‘int && &&’’ is an int&&
    using lr_rr_i = rr_i&;      // ‘‘int && &’’ is an int&
    using rr_lr_i = lr_i&&;     // ‘‘int & &&’’ is an int&
    using lr_lr_i = lr_i&;      // ‘‘int & &’’ is an int&