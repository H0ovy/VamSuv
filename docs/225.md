# Pages 200-225

## Structures

An array is an aggregate of elements of the same type. In its simplest form, a `struct` is an aggregate of elements of arbitrary types. For example:

    struct Address {
        const char∗ name;       // "Jim Dandy"
        int number;             // 61
        const char∗ street;     // "South St"
        const char∗ town;       // "New Providence"
        char state[2];          // ’N’ ’J’
        const char∗ zip;        // "07974"
    };

Variables of type `Address` can be declared exactly like other variables, and the individual members can be accessed using the . (dot) operator. For example:

    void f()
    {
        Address jd;
        jd.name = "Jim Dandy";
        jd.number = 61;
    }

Structures are often accessed through pointers using the `−>` (`struct` pointer dereference) operator.
For example:

    void print_addr(Address∗ p)
    {
        cout << p−>name << '\n'
             << p−>number << ' ' << p−>street << '\n'
             << p−>town << '\n'
             << p−>state[0] << p−>state[1] << ' ' << p−>zip << '\n';
    }

When `p` is a pointer, `p−>m` is equivalent to `(∗p).m`.

Alternatively, a `struct` can  be  passed  by  reference  and  accessed  using  the `.` (`struct` member access) operator:

    void print_addr2(const Address& r)
    {
        cout << r.name << '\n'
             << r.number << ' ' << r.street << '\n'
             << r.town << '\n'
             << r.state[0] << r.state[1] << ' ' << r.zip << '\n';
    }

Objects  of  structure  types  can  be  assigned,  passed  as  function  arguments,  and  returned  as  the result from a function. For example:

    Address current;

    Address set_current(Address next)
    {
        address prev = current;
        current = next;
        return prev;
    }

Struct constructors:

    struct Address {
        string name;        // "Jim Dandy"
        int number;         // 61
        string street;      // "South St"
        string town;        // "New Providence"
        char state[2];      // ’N’ ’J’
        char zip[5];        // 07974

        Address(const string n, int nu, const string& s, const string& t, const string& st, int z);
    };

Here,  I  added  a  constructor  to  ensure  that  every  member  was  initialized  and  to  allow me to use  a string and an int for the postal code, rather than fiddling with individual characters. For example:

    Address jd = {
        "Jim Dandy",
        61, "South St",
        "New Providence",
        "NJ", 7974          // (07974 would be octal)
    };

The Address constructor might be defined like this:

    Address::Address(const string& n, int nu, const string& s, const string& t, const string& st, int z)
        // validate postal code
        :name{n},
        number{nu},
        street{s},
        town{t}
    {
        if (st.size()!=2)
            error("State abbreviation should be two characters")
        state = {st[0],st[1]};  // store postal code as characters
        ostringstream ost;      // an output string stream; see §38.4.2
        ost << z;               // extract characters from int
        string zi {ost.str()};
        switch (zi.siz e()) {
        case 5:
            zip = {zi[0], zi[1], zi[2], zi[3], zi[4]};
            break;
        case 4:                 // star ts with ’0’
            zip = {'0', zi[0], zi[1], zi[2], zi[3]};
            break;
        default:
            error("unexpected ZIP code format");
        }
            // ... check that the code makes sense ...
    }

## Enum classes

An `enum class` is a scoped and strongly typed enumeration. For example:

    enum class Traffic_light { red, yellow, green };
    enum class Warning { green, yellow, orang e, red }; // fire alert levels

    Warning a1 = 7;                             // error : no int->Warning conversion
    int a2 = green;                             // error : green not in scope
    int a3 = Warning::green;                    // error : no War ning->int conversion
    Warning a4 = Warning::green;                // OK

    void f(Traffic_light x)
    {
    if (x == 9) { /* ... */ }                   // error : 9 is not a Traffic_light
    if (x == red) { /* ... */ }                 // error : no red in scope
    if (x == Warning::red)  { /* ... */ }       // error : x is not a War ning
    if (x == Traffic_light::red) { /* ... */ }  // OK
    }

Declaring a variable `Warning` instead of plain `int` can give both the user and the compiler a hint as to the intended use. For example:

    void f(Warning key)
    {
        switch (key) {
        case Warning::green:
            // do something
            break;
        case Warning::orang e:
            // do something
            break;
        case Warning::red:
            // do something
            break;
        }
    }

A human might notice that `yellow` was missing, and a compiler might issue a warning because only three out of four `Warning` values are handled.

