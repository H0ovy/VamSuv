# Page 300-325

## Function returning values

    string to_string(int a);            // prefix return type
    auto to_string(int a) −> string;    // suffix return type

That is, a prefix `auto` indicates that the return type is placed after the argument list. The suffix return type is preceded by `−>`.

The essential use for a suffix return type comes in function template declarations in which the return type depends on the arguments. For example:

    template<class T, class U>
    auto product(const vector<T>& x, const vector<U>& y) −> decltype(x∗y);

A call of a `void` function may be used as the return value of a `void` function.  For example:

    void g(int∗ p);

    void h(int∗ p)
    {
    // ...
    return g(p);        // OK: equivalent to ‘‘g(p); return;’’
    }

## \[[noreturn]] Functions

Placing `[[noreturn]]` at  the  start  of  a  function  declaration  indicates  that  the  function  is  notexpected to return. For example:

    [[noreturn]] void exit(int);    // exit will never retur n

## Reference Arguments

declaring a pointer(`*`) argument `const` tells readers that the value of an object pointed to by that argument is not changed by the function. For example:

    int strlen(const char∗);                        // number of characters in a C-style string
    char∗ strcpy(char∗ to, const char∗ from);       // copy a C-style string
    int strcmp(const char∗, const char∗);           // compare C-style strings

## Array Arguments

If an array is used as a function argument, a pointer to its initial element is passed. For example:

    int strlen(const char∗);

    void f()
    {
        char v[] = "Annemarie";
        int i = strlen(v);
        int j = strlen("Nicholas");
    }

For arrays,  a second argument specifying the size can be passed. For example:

    void compute1(int∗ vec_ptr, int vec_size);  // one way

If you really want to pass an array, rather than a container or a pointer to the first element of an array, you can declare a parameter of type reference to array. For example:

    void f(int(&r)[4]);

    void g()
    {
        int a1[] = {1,2,3,4};
        int a2[] = {1,2};

        f(a1);                  // OK
        f(a2);                  // error : wrong number of elements
    }

## Unspecified Number of Arguments

(one of three ways)

For example:

    int printf(const char∗ ...);

This specifies that a call of the standard-library function printf() must have at least one argument, a C-style string, but may or may not have others.  For example:

    printf("Hello, world!\n");
    printf("My name is %s %s\n", first_name , second_name);
    printf("%d + %d = %d\n",2,3,5);

Such a function must rely on information not available to the compiler when interpreting its argument  list. In  the  case  of `printf()`, the  first  argument  is  a  format  string  containing  special  character sequences  that  allow `printf()` to  handle  other  arguments  correctly; `%s` means  ‘‘expect  a `char∗` argument’’ and `%d` means  ‘‘expect  an `int` argument.’’

## Default Arguments

Consider class complex:

    class complex {
        double re, im;
    public:
        complex(double r, double i) :re{r}, im{i} {} // construct complex from two scalars
        complex(double r) :re{r}, im{0} {} // construct complex from one scalar
        complex() :re{0}, im{0} {}
    // default complex: {0,0}
        // ...
    };

We  could deal with the repetitiveness by considering one of the constructors ‘‘the real one’’ and forward to that:

    complex(double r, double i) :re{r}, im{i} {}    // construct complex from two scalars
    complex(double r) :complex{2,0} {}              // construct complex from one scalar
    complex() :complex{0,0} {}                      // default complex: {0,0}

However, this can be abbreviated further:

    complex(double r ={}, double i ={}) :re{r}, im{i} {}    // construct complex from two scalars

This makes it clear that if a user supplies fewer than the two arguments needed, the default is used.

