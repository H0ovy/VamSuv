# Page 275-300

## Free Space 

A named object has its lifetime determined by its scope. However, it is often useful to create an object that exists independently of the scope in which it was created. For example, it is common to create objects that can be used after returning from the function in which they were created. The operator `new` creates such objects, and the operator `delete` can be used to destroy them.

`new()` - for an object
`new[]()` - for an array

same with `delete`

## nothrow new

In programs where exceptions must be avoided, we can use nothrow versions of new and delete. For example:

    void∗ operator new(siz e_t sz, const nothrow_t&) noexcept;      // allocate sz bytes;
                                                                    // return nullptr if allocation failed
    void operator delete(void∗ p, const nothrow_t&) noexcept;       // deallocate space allocated by new
    void∗ operator new[](siz e_t sz, const nothrow_t&) noexcept;    // allocate sz bytes;
                                                                    // return nullptr if allocation failed
    void operator delete[](void∗ p, const nothrow_t&) noexcept;     // deallocate space allocated by new

## Lists

In addition to their use for initializing named variables, `{}`-lists can be used as expressions in many (but not all) places. They can appear in two forms:

- Qualified by  a  type, `T{...}`, meaning  ‘‘create  an  object  of  type `T` initialized  by `T{...}`’’;
§11.3.2
- Unqualified `{...}`, for  which  the  the  type  must  be  determined  from  the  context  of  use;
For example:

    struct S { int a, b; };
    struct SS { double a, b; };

    void f(S);          // f() takes an S

    void g(S);
    void g(SS);         // g() is overloaded

    void h()
    {
        f({1,2});       // OK: call f(S{1,2})
        g({1,2});       // error : ambiguous
        g(S{1,2});      // OK: call g(S)
        g(SS{1,2});     // OK: call g(SS)
    }

## Unqualified Lists

A unqualified  list  is  used  where  an  expected  type  is  unambiguously  known.
For example:

    int f(double d, Matrix& m)
    {
        int v {7};          // initializer (direct initialization)
        int v2 = {7};       // initializer (copy initialization)
        int v3 = m[{2,3}];  // assume m takes value pairs as subscripts

        v = {8};            // right-hand operand of assignment
        v += {88};          // right-hand operand of assignment
        {v} = 9;            // error : not left-hand operand of assignment
        v = 7+{10};         // error : not an operand of a non-assignment operator
        f({10.0});          // function argument
        return {11};        // return value
    }

Unfortunately, we do not deduce the type of an unqualified list for a plain template argument.  Forexample:

    template<typename T>
    void f(T);

    f({});          // error : type of initializer is unknown
    f({1});         // error : an unqualified list does not match ‘‘plain T’’
    f({1,2});       // error : an unqualified list does not match ‘‘plain T’’
    f({1,2,3});     // error : an unqualified list does not match ‘‘plain T’’

Similarly, we do not  deduce  the  element  type  of  a  container  represented  as  a  template. Forexample:

    template<class T>
    void f2(const vector<T>&);

    f2({1,2,3});                // error : cannot deduce T
    f2({"Kona","Sidney"});      // error : cannot deduce T

## The Type of Lambda

For example, I might try to write a lambda to reverse the characters in a C-style string:

    auto rev = [&rev](char∗ b, char∗ e)
                    { if (1<e −b) { swap(∗b,∗−−e); rev(++b,e); } };     // error

However, that’s not possible because I cannot use an `auto` variable before its type has been deduced.
Instead, I can introduce a name and then use it:

    void f(string& s1, string& s2)
    {
        function<void(char∗ b, char∗ e)> rev =
            [&](char∗ b, char∗ e) { if (1<e−b) { swap(∗b,∗−−e); rev(++b,e); } };

        rev(&s1[0],&s1[0]+s1.siz e());
        rev(&s2[0],&s2[0]+s2.siz e());
        }

## Construction 

The  construction  of  a  value  of  type T from  a  value e can  be  expressed  by  the  notation T{e}
For example:

    auto d1 = double{2};        // d1==2.0
    double d2 {double{2}/4};    // d1==0.5