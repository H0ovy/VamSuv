# Page 25-50
"To write a good program takes intelligence, taste, and patience. You are not going to get
it right the first time. Experiment!"

- +x - унарный плюс   (до сих пор не до конца понял, что эт за фрукт, но он может, например выводить значение чаров в инты (если чар - цифра), например char x = 5;   cout <<+x; - cout выведит 5)
- -x - унарный минус - изменяет значение на негативное (10 превращается в -10)
- x+=y // x = x+y
- ++x // increment: x = x+1
- x−=y // x = x-y
- −−x // decrement: x = x-1
- x∗=y // scaling: x = x*y
- x/=y // scaling: x = x/y
- x%=y // x = x%y

## Const
- `const`: meaning roughly ‘‘I promise not to change this value’’.  This is used primarily to specify interfaces, so that data can be passed to functions without fear of it being modified. The compiler enforces the promise made by const.
- `constexpr`: meaning roughly ‘‘to be evaluated at compile time’’.  This is used primarily to specify constants, to allow placement of data in memory where it is unlikely to be corrupted, and for performance.

## Switch
Example:

    bool accept2()
    {
        cout << "Do you want to proceed (y or n)?\n"; // write question

        char answer = 0;
        cin >> answer; // read answer

        switch (answer) {
        case 'y':
            return true;
        case 'n':
            return false;
        default:
            cout << "I'll take that for a no.\n";
            return false;
        }
    }
A switch-statement tests a value against a set of constants. The case constants must be distinct, and if the value tested does not match any of them, the default is chosen. If no default is provided, no action is taken if the value doesn’t match any case constant.

## Pointers, Arrays, and Loops
    char∗ p = &v[3]; // p points to v’s four th element
    char x = ∗p; // *p is the object that p points to

In an expression, prefix unary ∗ means ‘‘contents of’’  and prefix unary & means ‘‘address of.’’ We
can represent the result of that initialized definition graphically:

In  a  declaration,  the  unary  suffix & means  ‘‘reference  to.’’ A reference  is  similar  to  a  pointer, except that you don’t need to use a prefix ∗ to access the value referred to by the reference. Also, a reference cannot be made to refer to a different object after its initialization. When used in declarations, operators (such as &, ∗, and []) are called declarator operators.

We  try to ensure that a pointer always points to an object, so that dereferencing it is valid.  When
we don’t hav e an object to point to or if we need to represent the notion of ‘‘no object available’’
(e.g., for an end of a list), we give the pointer the value `nullptr` (‘‘the null pointer’’).  There is only
one `nullptr` shared by all pointer types:

    double∗ pd = nullptr;
    Link<Record>∗ lst = nullptr; // pointer to a Link to a Record
    int x = nullptr; // error : nullptr is a pointer not an integer

It  is  often  wise  to  check  that  a  pointer  argument  that  is  supposed  to  point  to  something,  actually
points to something:

    int count_x(char∗ p, char x)
        // count the number of occurrences of x in p[]
        // p is assumed to point to a zero-ter minated array of char (or to nothing)
    {
        if (p==nullptr) return 0;
        int count = 0;
        for (; ∗p!=0; ++p)
            if (∗p==x)
                ++count;
        return count;
    }

## Struct
Example:

    struct Vector {
        int sz; // number of elements
        double∗ elem;  // pointer to elements
    };
    void vector_init(Vector& v, int s)
    {
        v.elem = new double[s]; // allocate an array of s doubles
        v.sz = s;
    }

A simple use:

    double read_and_sum(int s)
        // read s integers from cin and return their sum;
        // s is assumed to be positive
    {
        Vector v;
        vector_init(v,s); // allocate s elements for v
        for (int i=0; i!=s; ++i)
            cin>>v.elem[i]; // read into elements

        double sum = 0;
        for (int i=0; i!=s; ++i)
            sum+=v.elem[i]; // take the sum of the elements
        return sum;
    }

## Classes
An example:

    class Vector {
        public:
            Vector(int s) :elem{new double[s]}, sz{s} { } // constr uct a Vector
            double& operator[](int i) { return elem[i]; } // element access: subscripting
            int size() { return sz; }
        private:
            double∗ elem;  // pointer to the elements
            int sz; // the number of elements
    };
    Vector v(6); // a Vector with 6 elements

Example of use:

    double read_and_sum(int s)
    {
        Vector v(s); // make a vector of s elements
        for (int i=0; i!=v.siz e(); ++i)
            cin>>v[i]; // read into elements
            
        double sum = 0;
        for (int i=0; i!=v.siz e(); ++i)
            sum+=v[i]; // take the sum of the elements
        return sum;
    }