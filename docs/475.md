# Page 450-475

## Classes

An example of a class and it's functions:

    class Date {
    public:
        Date (int dd, int mm, int yy) { d = dd; m = mm; y = yy; };       // constructor
        void add_year(int n);                                           // add n years
        void add_month(int n);                                          // add n months
        void add_day(int n);                                            // add n days
        int print_month();
    private:
        int d, m, y;
    };

    void Date::add_year(int n)
    {
        y += n; 
    }

    void Date::add_day(int n)
    {
        d += n; 
    }

    void Date::add_month(int n)
    {
        m += n; 
    }

    int Date::print_month()
    {
        return m;
    }

    int main() {
        Date dx {25, 3, 2011}; 
        cout<< dx.print_month();
    }

## `class` and `struct`

The construct

    class X { ... };

is  called  a class  definition; it defines  a  type  called `X`.
By definition, a struct is a class in which members are by default public; that is,

    struct S { /* ... */ };

is simply shorthand for

    class S { public: /* ... */ };

By default, members of a class are private:

    class Date1 {
        int d, m, y;                    // private by default
    public:
        Date1(int dd, int mm, int yy);
        void add_year(int n);           // add n years
    };

However, we can also use the access specifier `private`: to say that the members following are private.

By providing several constructors, we can provide a variety of ways of initializing objects of a type.  For example:

    class Date {
        int d, m, y;
    public:
        // ...
        Date(int, int, int);        // day,  month, year
        Date(int, int);             // day,  month, today’s year
        Date(int);                  // day,  today’s month and year
        Date();                     // default Date: today
        Date(const char∗);          // date in string representation
    };

A constructor declared  with  the  keyword `explicit` can  only be used for initialization and explicit conversions.

## Constant Member Functions

The `Date` as defined so far provides member functions for giving a `Date` a value.  Unfortunately, we didn’t provide  a  way  of  examining  the  value  of  a `Date`. This  problem  can  easily  be  remedied  by adding functions for reading the day, month, and year:

    class Date {
        int d, m, y;
    public:
        int day() const { return d; }
        int month() const { return m; }
        int year() const;
        void add_year(int n);   // add n years
        // ...
    };

The `const` after the (empty) argument list in the function declarations indicates that these functions do not modify the state of a `Date`.

## `mutable`

We  can define a member of a class to be `mutable`, meaning that it can be modified even in a `const` object:

    class Date {
    public:
        // ...
        string string_rep() const;          // string representation
    private:
        mutable bool cache_valid;
        mutable string cache;
        void compute_cache_value() const;   // fill (mutable) cache
        // ...
    };

Now we can define `string_rep()` in the obvious way:

    string Date::string_rep() const
    {
        if (!cache_valid) {
            compute_cache_value();
            cache_valid = true;
        }
        return cache;
    }

We  can now use `string_rep()` for both const and non-const objects. For example:

    void f(Date d, const Date cd)
    {
        string s1 = d.string_rep();
        string s2 = cd.string_rep();    // OK!
        // ...
    }

## Self-Reference

The  state  update  functions add_year(), add_month(), and add_day() were defined not to return values. For such a set of related update functions, it is often useful to return a reference to the updated object so that the operations can be chained. For example, we would like to write:

    void f(Date& d)
    {
    // ...
    d.add_day(1).add_month(1).add_year(1);
    // ...
    }

to add a day, a month, and a year to d. To do this, each function must be declared to return a reference to a Date:

    class Date {
        // ...

        Date& add_year(int n);      // add n years
        Date& add_month(int n);     // add n months
        Date& add_day(int n);       // add n days
    };

Each (non-static) member function knows for which object it was invoked and can explicitly refer to it. For example:

    Date& Date::add_year(int n)
    {
        if (d==29 && m==2 && !leapyear(y+n)) { // beware of Febr uary 29
            d = 1; 
            m = 3; 
        }
        y += n; 
        return ∗this;
    }

The expression `∗this` refers to the object for which a member function is invoked. 
In a non-`static` member function, the keyword `this` is a pointer to the object for which the function was invoked. In a non-`const` member function of class `X`, the type of this is `X∗`. However, `this` is  considered  an  rvalue,  so  it  is  not  possible  to  take the  address  of `this` or  to  assign  to `this`. In a  `const` member function of class `X`, the type of `this` is `const  X∗` to prevent modification of the object itself.

## Member Access

A member of a class `X` can be accessed by applying the `.` (dot) operator to an object of class `X` or by applying the `−>` (arrow) operator to a pointer to an object of class `X`. For example:

    struct X {
        void f();
        int m;
    };

    void user(X x, X∗ px)
    {
        m = 1;      // error : there is no m in scope
        x.m = 1;    // OK
        x−>m = 1;   // error : x is not a pointer
        px−>m = 1;  // OK
        px.m = 1;   // error : px is a pointer
    }

## [static] Members

A variable that is part of a class, yet is not part of an object of that class, is called `a static` member. There is exactly one copy of a `static` member instead of one copy per object, as for ordinary  non-`static` members. Similarly, a  function  that  needs  access  to  members  of  a class, yet doesn’t need to be invoked for a particular object, is called a `static` member function.
Here is a redesign that preserves the semantics of default constructor values for `Date` without the problems stemming from reliance on a global:

    class Date {
        int d, m, y;
        static Date default_date;
    public:
        Date(int dd =0, int mm =0, int yy =0);
        // ...
        static void set_default(int dd, int mm, int yy); // set default_date to Date(dd,mm,yy)
    };

We  can now define the `Date` constructor to use `default_date` like this:

    Date::Date(int dd, int mm, int yy)
    {
        d = dd ? dd : default_date  .d;
        m = mm ? mm : default_date .m;
        y = yy ? yy : default_date .y;
        // ... check that the Date is valid ...
    }

For example:

    void f()
    {
        Date::set_default(4,5,1945);    // call Date’s static member set_default()
    }

If used, a `static` member – a function or data member – must be defined somewhere. The keyword `static` is not repeated in the definition of a `static` member. For example:

    Date Date::default_date {16,12,1770};           // definition of Date::default_date

    void Date::set_default(int d, int m, int y)     // definition of Date::set_default
    {
        default_date = {d,m,y};                     // assign new value to default_date
    }

## Member Types

Types and type aliases can be members of a class. For example:

    template<typename T>
    class Tree {
            using value_type = T;               // member alias
            enum Policy { rb, splay, treeps };  // member enum
            class Node {                        // member class
                Node∗ right;
                Node∗ left;
                value_type value;
            public:
                void f(Tree∗);
            };
            Node∗ top;
        public:
            void g(const T&);
            // ...
    };

## Concrete Classes

let us build a better `Date` class:

    namespace Chrono {

    enum class Month { jan=1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec };

    class Date {
    public: // public interface:
        class Bad_date { };                                     // exception class

        explicit Date(int dd ={}, Month mm ={}, int yy ={});    // {} means ‘‘pick a default’’

    // nonmodifying functions for examining the Date:
        int day() const;
        Month month() const;
        int year() const;

        string string_rep() const; // string representation
        void char_rep(char s[], in max) const;                  // C-style string representation

    // (modifying) functions for changing the Date:
        Date& add_year(int n);                                  // add n years
        Date& add_month(int n);                                 // add n months
        Date& add_day(int n);                                   // add n days
    private:
        bool is_valid();                                        // check if this Date represents a date
        int d, m, y;                                            // representation
    };

    bool is_date(int d, Month m, int y);    // true for valid date
    bool is_leapyear(int y);                // true if y is a leap year

    bool operator==(const Date& a, const Date& b);
    bool operator!=(const Date& a, const Date& b);

    const Date& default_date();             // the default date

    ostream& operator<<(ostream& os, const Date& d);    // print d to os 
    istream& operator>>(istream& is, Date& d);          // read Date from is into d
    }   // Chrono

Here is a small – and contrived – example of how `Date`s can be used:

    void f(Date& d)
    {
        Date lvb_day {16,Month::dec,d.year()};

        if (d.day()==29 && d.month()==Month::feb) {
            // ...
        }

        if (midnight()) d.add_day(1);

        cout << "day after:" << d+1 << '\n';

        Date dd; // initialized to the default date
        cin>>dd;
        if (dd==d) cout << "Hurray!\n";
    }

This assumes that the addition operator, `+`, has been declared for `Date`s.