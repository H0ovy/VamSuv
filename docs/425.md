# Page 400-425

## Namespaces: Convenience vs. Safety

    namespace X {
        int i, j, k;
    }
    
    int k;

    void f1()
    {
        int i = 0;
        using namespace X;      // make names from X accessible
        i++;                    // local i
        j++;                    // X::j
        k++;                    // error : X’s k or the global k?
        ::k++;                  // the global k
        X::k++;                 // X’s k
    }

    void f2()
    {
        int i = 0;
        using X::i;     // error : i declared twice in f2()
        using X::j;
        using X::k;     // hides global k
        i++;
        j++;            // X::j
        k++;            // X::k
    }

## Namespace Aliases

Long namespace names can be impractical in real code:

    namespace American_Telephone_and_Telegraph {    // too long
        // ...
    }

    American_Telephone_and_Telegraph::String s3 = "Grieg";
    American_Telephone_and_Telegraph::String s4 = "Nielsen";

This dilemma can be resolved by providing a short alias for a longer namespace name:

    // use namespace alias to shorten names:

    namespace ATT = American_Telephone_and_Telegraph;

    ATT::String s3 = "Grieg";
    ATT::String s4 = "Nielsen";

## Namespace Composition

Often, we want to compose an interface out of existing interfaces.  For example:

    namespace His_string {
        class String { /* ... */ };
        String operator+(const String&, const String&);
        String operator+(const String&, const char∗);
        void fill(char);
        // ...
    }

    namespace Her_vector {
        template<class T>
            class Vector { /* ... */ };
        // ...
    }

    namespace My_lib {
        using namespace His_string;
        using namespace Her_vector;
        void my_fct(String&);
    }

Given this, we can now write the program in terms of My_lib:

    void f()
    {
        My_lib::String s = "Byron"; // finds My_lib::His_string::Str ing
        // ...
    }

    using namespace My_lib;

    void g(Vector<String>& vs)
    {
        // ...
        my_fct(vs[5]);
        // ...
    }

Only if we need to define something do we need to know the real namespace of an entity:

    void My_lib::fill(char c)       // error : no fill() declared in My_lib
    {
        // ...
    }
    void His_string::fill(char c)   // OK: fill() declared in His_string
    {
        // ...
    }
    void My_lib::my_fct(String& v)  // OK: String is My_lib::String, meaning His_string::Str ing
    {
        // ...
    }

## Composition and Selection

Combining composition (by `using`-directives) with selection (by `using`-declarations) yields the flexibility  needed  for  most  real-world  examples. With  these  mechanisms,  we  can  provide  access  to  a variety of facilities in such a way that we resolve name clashes and ambiguities arising from their composition.  For example:

    namespace His_lib {
        class String { /* ... */ };
        template<class T>
            class Vector { /* ... */ };
        // ...
    }

    namespace Her_lib {
        template<class T>
            class Vector { /* ... */ };
        class String { /* ... */ };
        // ...
    }

    namespace My_lib {
        using namespace His_lib;        // everything from His_lib
        using namespace Her_lib;        // everything from Her_lib

        using His_lib::String;          // resolve potential clash in favor of His_lib
        using Her_lib::Vector;          // resolve potential clash in favor of Her_lib

        template<class T>
            class List { /* ... */ };   // additional stuff
        // ...
    }

Consequently, a user  of `My_lib` will  see  the  name  clashes  for `String` and `Vector` resolved  in  favor of `His_lib::String` and `Her_lib::Vector`. Also, `My_lib::List` will  be  used  by  default independently of whether `His_lib` or `Her_lib` is providing a `List`.

However, sometimes a new name is needed or simply nice to have. For example:

    namespace Lib2 {
        using namespace His_lib;                    // everything from His_lib
        using namespace Her_lib;                    // everything from Her_lib

        using His_lib::String;                      // resolve potential clash in favor of His_lib
        using Her_lib::Vector;                      // resolve potential clash in favor of Her_lib

        using Her_string = Her_lib::String;         // rename
        template<class T>
            using His_vec = His_lib::Vector<T>;     // rename

        template<class T>
            class List { /* ... */ };               // additional stuff
        // ...
    }

## Namespaces and Overloading

    // old A.h:
        void f(int);
        // ...

    // old B.h:
        void f(char);
        // ...

    // old user.c:
        #include "A.h"
        #include "B.h"

        void g()
        {
            f('a');     // calls the f() from B.h
        }

## Versioning

    namespace Popular {
        inline namespace V3_2 { // V3_2 provides the default meaning of Popular
            double f(double);
            int f(int);
            template<class T>
            c   lass C { /* ... */ };
        }

        namespace V3_0 {
            // ...
        }

        namespace V2_4_2 {
            double f(double);
            template<class T>
                class C { /* ... */ };
        }
    }

Here, `Popular` contains three subnamespaces, each defining a version. The `inline` specifies that `V3_2` is the default meaning of `Popular`. So we can write:

    using namespace Popular;

    void f()
    {
        f(1);               // Popular ::V3_2::f(int)
        V3_0::f(1);         // Popular ::V3_0::f(double)
        V2_4_2::f(1);       // Popular ::V2_4_2::f(double)
    }

    template<class T>
    Popular::C<T∗> { /* ... */ };

## Nested Namespaces

For example:

    void h();

    namespace X {
        void g();
        // ...
        namespace Y {
            void f();
            void ff();
            // ...
        }
    }

The usual scope and qualification rules apply:

    void X::Y::ff()
    {
        f(); g(); h();
    }

    void X::g()
    {
        f();        // error : no f() in X
        Y::f();     // OK
    }

    void h()
    {
        f();        // error : no global f()
        Y::f();     // error : no global Y
        X::f();     // error : no f() in X
        X::Y::f();  // OK
    }

## Unnamed namespaces

We can simply leave the namespace without a name:

    #include "header.h"

    namespace {
        int a;
        void f() { /* ... */ }
        int g() { /* ... */ }
    }

The previous declaration is equivalent to:

    namespace $$$ {
        int a;
        void f() { /* ... */ }
        int g() { /* ... */ }
    }
    using namespace $$$;

## Linkage

For example, consider two files:

    // file1.cpp:
        int x = 1;
        int f() { /* do something */ }

    // file2.cpp:
        extern int x;
        int f();
        void g() { x = f(); }

The `x` and `f()` used by `g()` in `file2.cpp` are the ones defined in `file1.cpp`. The keyword extern indicates that  the  declaration  of x in `file2.cpp` is  (just)  a  declaration  and  not  a  definition. 

A name that can be referred to only in the translation unit in which it is defined is said to have internal linkage.
For example:

    static int x1 = 1; // internal linkage: not accessible from other translation units
    const char x2 = 'a'; // internal linkage: not accessible from other translation units

When  used  in  namespace  scope  (including  the  global  scope),  the  keyword `static` means  ‘‘not  accessible  from  other  source  files’’.
The keyword `const` implies default internal linkage, so if you wanted `x2` to have external linkage, you need to precede its definitions with `extern`:

    int x1 = 1;                     // external linkage: accessible from other translation units
    extern const char x2 = 'a';     // external linkage: accessible from other translation units
