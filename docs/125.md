# Page 100-125

## Map

Example of map:

    map<string,int> phone_book {
        {"David Hume",123456},
        {"Karl Popper",234567},
        {"Ber trand Ar thur William Russell",345678}
    };

Example of an unordered map:

    unordered_map<string,int> phone_book {
        {"David Hume",123456},
        {"Karl Popper",234567},
        {"Bertrand Ar thur William Russell",345678}
    };

## Use of Iterators

    bool has_c(const string& s, char c)      // does s contain the character c?
    {
        auto p = find(s.begin(),s.end(),c);
        if (p!=s.end())
            return true;
        else
            return false;
    }

What is common for all iterators is their semantics and the naming of their operations. For example, applying `++` to any iterator yields an iterator that refers to the next element. Similarly, `∗` yields the element to which the iterator refers.

## Algorithms

p=find(b,e,x) p is the first p in [b:e) so that `∗p==x`
p=find_if(b,e,f) p is the first p in [b:e) so that `f(∗p)==true`
n=count(b,e,x) n is the number of elements ∗q in [b:e) so that `∗q==x`
n=count_if(b,e,f) n is the number of elements ∗q in [b:e) so that `f(∗q,x)`
replace(b,e,v,v2) Replace elements ∗q in [b:e) so that `∗q==v` by v2
replace_if(b,e,f,v2) Replace elements ∗q in [b:e) so that `f(∗q)` by v2
p=copy(b,e ,out) Copy [b:e) to [ out:p)
p=copy_if(b,e ,out,f) Copy elements ∗q from [b:e) so that `f(∗q)` to [out:p)
p=unique_copy(b,e ,out) Copy [b:e) to [ out:p); don’t copy adjacent duplicates
sort(b,e) Sort elements of [b:e) using < as the sorting criterion
sort(b,e,f) Sort elements of [b:e) using f as the sorting criterion
(p1,p2)=equal_range(b,e,v) [p1:p2) is the subsequence of the sorted sequence [b:e) with the value v; basically a binary search for v
p=merge(b,e ,b2,e2,out) Merge two sorted sequences [b:e) and [b2:e2) into [out:p)

## Events

"Waiting"

    using namespace std::chrono;

    auto t0 = high_resolution_clock::now();
    this_thread::sleep_for(milliseconds{20});
    auto t1 = high_resolution_clock::now();
    cout << duration_cast<nanoseconds>(t1−t0).count() << " nanoseconds passed\n";

Another use of time:

    using namespace std::chrono;

    auto t0 = high_resolution_clock::now();
    do_work();
    auto t1 = high_resolution_clock::now();
    cout << duration_cast<milliseconds>(t1−t0).count() << "msec\n";

