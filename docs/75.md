# Page 50-75

## Enumerations

    enum class Color { red, blue , green };
    enum class Traffic_light { green, yellow, red };

    Color col = Color::red;
    Traffic_light light = Traffic_light::red;

The class after the enum specifies that an enumeration is strongly typed and that its enumerators are  scoped. Being  separate  types, enum  classes  help  prevent  accidental  misuses  of  constants. In particular, we cannot mix `Traffic_light` and `Color` values:

    Color x = red; // error : which red?
    Color y = Traffic_light::red; // error : that red is not a Color
    Color z = Color::red; // OK

Similarly, we cannot implicitly mix `Color` and integer values:

    int i = Color::red; // error : Color ::red is not an int
    Color c = 2; // error : 2 is not a Color

By default, an enum  class has only assignment, initialization, and comparisons  defined. However, an enumeration is a user-defined type so we can define operators for it:

    Traffic_light& operator++(Traffic_light& t)
        // prefix increment: ++
    {
        switch (t) {
        case Traffic_light::green: return t=Traffic_light::yellow;
        case Traffic_light::yellow: return t=Traffic_light::red;
        case Traffic_light::red: return t=Traffic_light::green;
    }
    }
    Traffic_light next = ++light; // next becomes Traffic_light::green

## Separate compilation

_Vector.h_

    class Vector {
    public:
        Vector(int s);
        double& operator[](int i);
        int size();
    private:
        double∗ elem; // elem points to an array of sz doubles
        int sz;
    };

_user.cpp_

    #include "Vector.h" // get Vector’s interface
    #include <cmath> // get the the standard-librar y math function interface including sqrt()

    using namespace std; // make std members visible (§2.4.2)

    double sqrt_sum(Vector& v)
    {
        double sum = 0;
        for (int i=0; i!=v.siz e(); ++i)
            sum+=sqrt(v[i]); // sum of square roots
        return sum;
    }

_Vector.cpp_

    #include "Vector.h"  // get the interface

    Vector::Vector(int s)
        :elem{new double[s]}, sz{s}
    {
    }

    double& Vector::operator[](int i)
    {
        return elem[i];
    }

    int Vector::siz e()
    {
        return sz;
    }

## Exceptions

For example, `Vector::operator[]()` can detect an attempted out-of-range access and throw an `out_of_range` exception:'

    double& Vector::operator[](int i)
    {
        if (i<0 || size()<=i) throw out_of_rang e{"Vector::operator[]"};
        return elem[i];
    }

The throw transfers  control  to  a  handler  for  exceptions  of  type out_of_range in  some  function  that directly  or  indirectly  called `Vector::operator[]()`. To do that,  the  implementation  will  unwind  the function call stack as needed to get back to the context of that caller. For example:

    void f(Vector& v)
    {
        // ...
        try { // exceptions here are handled by the handler defined below

            v[v.siz e()] = 7; // tr y to access beyond the end of v
        }
        catch (out_of_rang e) { // oops: out_of_range error
            // ... handle range error ...
        }
        // ...
    }

We  put  code  for  which  we  are  interested  in  handling  exceptions  into  a try-block. That attempted assignment to `v[v.siz e()]` will fail.  Therefore, the catch-clause providing a handler for `out_of_range` will be entered.

## Static assertions

Exceptions (again)

    constexpr double C = 299792.458; // km/s
    void f(double speed)
    {
        const double local_max = 160.0/(60∗60); // 160 km/h == 160.0/(60*60) km/s

        static_assert(speed<C,"can't go that fast"); // error : speed must be a constant
        static_assert(local_max<C,"can't go that fast"); // OK
    // ...
    }

In general, `static_assert(A,S)` prints `S` as a compiler error message if `A` is not `true`.

## Arithmetic types

Example:

    class complex {
        double re, im; // representation: two doubles
    public:
        complex(double r, double i) :re{r}, im{i} {} // construct complex from two scalars
        complex(double r) :re{r}, im{0} {} // construct complex from one scalar
        complex() :re{0}, im{0} {} // default complex: {0,0}
        double real() const { return re; }
        void real(double d) { re=d; }
        double imag() const { return im; }
        void imag(double d) { im=d; }

        complex& operator+=(complex z) { re+=z.re , im+=z.im; return ∗this; } // add to re and im
                                                                              // and return the result
                                                                              // при вызове оператора += с этим классом сложатся значения re и im складываемых комп. чис.
        complex& operator−=(complex z) { re−=z.re , im −=z.im; return ∗this; }

        complex& operator∗=(complex); // defined out-of-class somewhere
        complex& operator/=(complex); // defined out-of-class somewhere
    };

Many useful  operations  do  not  require  direct  access  to  the  representation  of complex, so they can be defined separately from the class definition:

    complex operator+(complex a, complex b) { return a+=b; }
    complex operator−(complex a, complex b) { return a−=b; }
    complex operator−(complex a) { return {−a.real(), −a.imag()}; } // unary minus
    complex operator∗(complex a, complex b) { return a∗=b; }
    complex operator/(complex a, complex b) { return a/=b; }

The definitions of == and != are straightforward:

    bool operator==(complex a, complex b) // equal
    {
        return a.real()==b.real() && a.imag()==b.imag();
    }

    bool operator!=(complex a, complex b) // not equal
    {
        return !(a==b);
    }

    complex sqrt(complex);
    // ...

The  compiler  converts  operators  involving complex numbers  into  appropriate  function  calls. For example, `c!=b` means `operator!=(c,b)` and `1/a` means `operator/(complex{1},a)`.


## Destructors

    class Vector {
        private:
        double∗ elem; // elem points to an array of sz doubles
        int sz;
    public:
        Vector(int s) :elem{new double[s]}, sz{s} // constructor: acquire resources
        {
            for (int i=0; i!=s; ++i) elem[i]=0; // initialize elements
        }

        ~Vector() { delete[] elem; } // destructor: release resources

        double& operator[](int i);
        int size() const;
    };

Destructors  ensure  that  the  memory allocated by the constructor is deallocated

Example of use:

    void fct(int n)
    {
        Vector v(n);

        // ... use v ...

        {
            Vector v2(2∗n);
            // ... use v and v2 ...
        } // v2 is destroyed here

        // ... use v ..

    } // v is destroyed here

## Abstract classes

    class Container {
    public:
        virtual double& operator[](int) = 0; // pure virtual function
        virtual int size() const = 0; // const member function
        virtual  ̃Container() {} // destructor
    };

The word `virtual` means ‘‘may be redefined  later  in  a  class  derived from  this  one.’’ 

The use of `Container`:

    void use(Container& c)
    {
        const int sz = c.size();
        
        for (int i=0; i!=sz; ++i)
            cout << c[i] << '\n';
    }
