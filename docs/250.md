# Page 225-250

## if Statements

For example, if `x` is an integer, then

    if (x) // ...

means

    if (x != 0) // ...

For a pointer `p`,

    if (p) // ...

is  a  direct  statement  of  the  test  ‘‘Does `p` point  to  a  valid  object  (assuming  proper  initialization)?’’ and is equivalent to

    if (p != nullptr) // ...

Note that a ‘‘plain’’ `enum` can be implicitly converted to an integer and then to a `bool`, whereas an `enum class` cannot. For example:

    enum E1 { a, b };
    enum class E2 { a, b };

    void f(E1 x, E2 y)
    {
        if (x)          // OK
            // ...
        if (y)          // error : no conversion to bool
            // ...
        if (y==E2::a)   // OK
            // ...
    }

For choosing between two alternatives each of which produces a value, a conditional expression is a more direct expression of intent than an `if`-statement.  For example:

    int max(int a, int b)
    {
        return (a>b)?a:b;       // return the larger of a and b
    }

## switch Statement

A `switch`-statement can alternatively be written as a set of `if`-statements.  For example:

    switch (val) {
        case 1:
            f();
            break;
        case 2:
            g();
            break;
        default:
            h();
            break;
    }

This could be expressed as:

    if (val == 1)
        f();
    else if (val == 2)
        g();
    else
        h();

Beware that a case of a switch must be terminated (`break`) somehow unless you want to carry on executing the next case.
Consider:'

    switch (val) {          // beware
        case 1:
            cout << "case 1\n";
        case 2:
            cout << "case 2\n";
        default:
            cout << "default: case not found\n";
    }

Invoked with `val==1`, the output will greatly surprise the uninitiated:

    case 1
    case 2
    default: case not found

## Range-for Statements

The simplest loop is a range-`for`-statement; it simply gives the programmer access to each element of a range. For example:

    int sum(vector<int>& v)
    {
        int s = 0;
        for (int x : v)
            s+=x;
        return s;
    }

The for `(int  x  :  v)` can be read as ‘‘for each element `x` in the range `v`’’  or just ‘‘for each `x` in `v`.’’ The elements of v are visited in order from the first to the last.

If  you  need  to  modify  an  element  in  a  range-`for` loop,  the  element  variable  should  be  a  reference (`&`).
For example, we can increment each element of a `vector` like this:

    void incr(vector<int>& v)
    {
        for (int& x : v)
            ++x;
    }

    int main()
    {
        vector<int>V = {1, 2, 3};
        incr(V);
        for_each(V.begin(), V.end(), [](int x) { cout << x <<' '; });
    }

    output:
        //2 3 4

## do-Statements

A `do`-statement is similar to a `while`-statement except that the condition comes after the body. For example:

    void print_backwards(char a[], int i)       // i must be positive
    {
        cout << '{';
        do {
            cout << a[−−i];
        } while (i);
        cout << '}';
    }

## Loop exit

Sometimes, we don’t want to exit the loop completely, we just want to get to the end of the loop body. A continue skips the rest of the body of an iteration-statement. For example:

    void find_prime(vector<string>& v)
    {
        for (int i = 0; i!=v.siz e(); ++i) {
            if (!prime(v[i]) continue;
                return v[i];
            }
    }

So find_prime() could equivalently have been written as:

    void find_prime(vector<string>& v)
    {
        for (int i = 0; i!=v.siz e(); ++i) {
            if (!prime(v[i]) {
                return v[i];
            }
        }
    }

## goto Statements

    void do_something(int i, int j)
        // do something to a two-dimensional matrix called mn
    {
        for (i = 0; i!=n; ++i)
            for (j = 0; j!=m; ++j)
                if (nm[i][j] == a)
                    goto found;
        // not found
        // ...
    found:
        // nm[i][j] == a
    }

