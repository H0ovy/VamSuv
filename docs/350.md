# Page 325-350

An example of `struct` sorting

    struct User {
        const char∗ name;
        const char∗ id;
        int dept;
    };

    vector<User> heads = {
        "Ritchie D.M.", "dmr", 11271,
        "Sethi R.", "ravi", 11272,
        "Szymanski T.G.", "tgs", 11273,
        "Schr yer N.L.", "nls", 11274,
        "Schr yer N.L.", "nls", 11275,
        "Kernighan B.W.", "bwk", 11276
    };

    void print_id(vector<User>& v)
    {
        for (auto& x : v)
            cout << x.name << '\t' << x.id << '\t' << x.dept << '\n';
    }

We can write:

    int main()
    {
        cout << "Heads in alphabetical order:\n";
        sort(heads.begin(), head.end(),
            [](const User& x, const User& y) { return x.name<y.name; }
        );
        print_id(heads);
        cout << '\n';

        cout << "Heads in order of department number:\n";
        sort(heads.begin(), head.end(),
            [](const User& x, const User& y) { return x.dept<y.dept; }
        );
        print_id(heads);
    }

If  the  explicit  use  of `begin()` and `end(`) is annoying, it can be eliminated by using a version of sort() that takes a container:

    sort(heads,[](const User& x, const User& y) { return x.name<y.name; });

## Macros

A simple macro is defined like this:

    #define NAME rest of line

Where `NAME` is encountered as a token, it is replaced by `rest of line`. For example:

    named = NAME

will expand into

    named = rest of line

A macro can also be defined to take arguments.  For example:

    #define MAC(x,y) argument1: x argument2: y

When MAC is used, two argument strings must be presented. They will replace `x` and `y` when `MAC()` is expanded.  For example:

    expanded = MAC(foo bar, yuk yuk)

will be expanded into

    expanded = argument1: foo bar argument2: yuk yuk

A string can be created by concatenating two strings using the `##` macro operator. For example:

    #define NAME2(a,b) a##b
    int NAME2(hack,cah)();

will produce

    int hackcah();

A single `#` before a parameter name in a replacement string means a string containing the macro argument.  For example:

    #define printx(x) cout << #x " = " << x << '\n';
    int a = 7;
    string str = "asdf";
    void f()
    {
    printx(a);      // cout << "a" << " = " << a << ’\n’;
    printx(str);    // cout << "str" << " = " << str << ’\n’;
    }

The argument list (‘‘replacement list’’) of a macro can be empty:

    #define EMPTY() std::cout<<"empty\n"
    EMPTY();        // print "empty\n"
    EMPTY;          // error : macro replacement list missing

## Conditional Compilation

One use of macros is almost impossible to avoid.  The directive

    #ifdef IDENTIFIER

does  nothing  if `IDENTIFIER` is  defined,  but  if  it  is  not,  the  directive  causes  all  input  to  be  ignored until a #endif directive is seen.  For example:

    int f(int a
    #ifdef arg_two
    ,int b
    #endif
    );

Unless a macro called `arg_two` has been `#define`d , this produces:

    int f(int a
    );

## Predefined Macros

A few macros are predefined by the compiler:
- __cplusplus: defined in a C++ compilation (and not in a C compilation). Its value is `201103L` in a C++11 program; previous C++ standards have lower values.
- `__DATE__`: date in ‘‘yyyy:mm:dd’’ format.
- `__TIME__`: time in ‘‘hh:mm:ss’’ format.
- `__FILE__`: name of current source file.
- `__LINE__`: source line number within the current source file.
- `__FUNC__`: an implementation-defined C-style string naming the current function.
- `__STDC_HOSTED__`: `1` if the implementation is hosted; otherwise `0`. In addition, a few macros are conditionally defined by the implementation:
- `__STDC__`: defined in a C compilation (and not in a C++ compilation)
- `__STDC_MB_MIGHT_NEQ_WC__`: `1` if,  in  the  encoding  for `wchar_t`, a member  of  the  basic character set might have a code value that differs from its value as an ordinary character literal
- `__STDCPP_STRICT_POINTER_SAFETY__`: `1` if  the  implementation  has  strict  pointer  safety; otherwise undefined.
- `__STDCPP_THREADS__`: `1` if  a  program  can  have  more  than  one  thread  of  execution;  otherwise undefined

## Exceptions

Consider a simplified and stylized example:

    void taskmaster()
    {
        try {
            auto result = do_task();
            // use result
        }
        catch (Some_error) {
            // failure to do_task: handle problem
        }
    }

    int do_task()
    {
        // ...
        if (/* could perfor m the task */)
            return result;
        else
            throw Some_error{};
    }

An  exception  different  from Some_error indicates  a  failure  of taskmaster() to do its job and must be handled by whatever code invoked taskmaster().

##  Traditional Error Handling

- Terminate the program

    if (something_wrong) exit(1);

- Return  an  error  value.

    int get_int(); // get next integer from input

- Return a legal value and leave the program in an ‘‘error state.’ ’

    double d = sqrt(−1.0);

- Call an error-handler function. For example:

    if (something_wrong) something_handler(); // and possibly continue here